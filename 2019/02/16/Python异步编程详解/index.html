<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="HatBoy" />



<meta name="description" content="Python异步编程详解">
<meta name="keywords" content="Python,asyncio,异步并发">
<meta property="og:type" content="article">
<meta property="og:title" content="Python异步编程详解">
<meta property="og:url" content="https://hatboy.github.io/2019/02/16/Python异步编程详解/index.html">
<meta property="og:site_name" content="HatBoy的个人主页">
<meta property="og:description" content="Python异步编程详解">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://hatboy.github.io/2019/02/16/Python异步编程详解/1.png">
<meta property="og:image" content="https://hatboy.github.io/2019/02/16/Python异步编程详解/2.jpg">
<meta property="og:image" content="https://hatboy.github.io/2019/02/16/Python异步编程详解/3.jpg">
<meta property="og:image" content="https://hatboy.github.io/2019/02/16/Python异步编程详解/4.png">
<meta property="og:image" content="https://hatboy.github.io/2019/02/16/Python异步编程详解/5.png">
<meta property="og:image" content="https://hatboy.github.io/2019/02/16/Python异步编程详解/6.png">
<meta property="og:updated_time" content="2019-02-16T07:48:50.775Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python异步编程详解">
<meta name="twitter:description" content="Python异步编程详解">
<meta name="twitter:image" content="https://hatboy.github.io/2019/02/16/Python异步编程详解/1.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="HatBoy的个人主页" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/favicon.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Python异步编程详解 | HatBoy的个人主页</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>





    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?94c5bc16a94e5db3e2942494f0be64dd";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">HatBoy</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="true" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签&amp;分类</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:hatboy-dj@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/HatBoy/" title="GitHub"></a>
                            
                                <a class="fa 码云博客" href="http://hatboy.gitee.io/" title="码云博客"></a>
                            
                                <a class="fa CSDN" href="http://blog.csdn.net/dj1174232716" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cython/">Cython</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HID攻击/">HID攻击</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KCP/">KCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python-tips/">Python tips</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python模块tips/">Python模块tips</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python语法/">Python语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL注入/">SQL注入</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Teensy/">Teensy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web安全/">Web安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/asyncio/">asyncio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socks/">socks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内网渗透/">内网渗透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异步并发/">异步并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/硬件安全/">硬件安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/端口转发/">端口转发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/调试/">调试</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://fmxfmx.gitee.io/">FMX</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://jewelz.me/">Jewelz</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/talentisan/activities">轻狂书生</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://threetop.top/">ZCC</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://blog.csdn.net/u012017783">ZCC的CSDN</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://zcc888.gitee.io/">ZCC的博客</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">一枚爱Python,爱海贼,爱健身,喜欢好玩有趣事物的程序员……</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">HatBoy</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">HatBoy</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签&amp;分类</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:hatboy-dj@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/HatBoy/" title="GitHub"></a>
                            
                                <a class="fa 码云博客" target="_blank" href="http://hatboy.gitee.io/" title="码云博客"></a>
                            
                                <a class="fa CSDN" target="_blank" href="http://blog.csdn.net/dj1174232716" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-Python异步编程详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/16/Python异步编程详解/" class="article-date">
      <time datetime="2019-02-16T07:37:14.000Z" itemprop="datePublished">2019-02-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Python异步编程详解
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Python编程/">Python编程</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/asyncio/">asyncio</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异步并发/">异步并发</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <excerpt in="" index="" |="" 首页摘要="">

<p>Python异步编程详解</p>
<a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="一、异步编程相关概念"><a href="#一、异步编程相关概念" class="headerlink" title="一、异步编程相关概念"></a>一、异步编程相关概念</h2><h3 id="1、I-O模型"><a href="#1、I-O模型" class="headerlink" title="1、I/O模型"></a>1、I/O模型</h3><ul>
<li>IO操作实际过程涉及到内核和调用这个IO操作的进程。对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：<ul>
<li>1.等待数据准备 (Waiting for the data to be ready)</li>
<li>2.将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ul>
</li>
<li>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案：<ul>
<li>阻塞 I/O（blocking IO）</li>
<li>非阻塞 I/O（nonblocking IO）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven IO）</li>
<li>异步 I/O（asynchronous IO）</li>
</ul>
</li>
<li>阻塞 I/O：当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。<code>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。当进程进入阻塞状态，是不占用CPU资源的。</code></li>
<li>非阻塞 I/O：当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<code>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</code></li>
<li>I/O 多路复用：IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。<code>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</code></li>
<li>信号驱动 I/O：<code>等待数据就绪阶段不阻塞，数据就绪后内核给进程发信号，复制数据阶段阻塞。</code></li>
<li>异步 I/O：用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。<code>也就是说异步 I/O两个阶段都不阻塞。</code></li>
<li>可用下图表示：<br><img src="/2019/02/16/Python异步编程详解/1.png" alt="1.png"></li>
</ul>
<h3 id="2、同步和异步、阻塞和非阻塞"><a href="#2、同步和异步、阻塞和非阻塞" class="headerlink" title="2、同步和异步、阻塞和非阻塞"></a>2、同步和异步、阻塞和非阻塞</h3><ul>
<li>同步和异步：对于同步和异步而言，往往是一个函数调用之后，是否直接返回结果，如果函数挂起，直到获得结果，这是同步；如果函数马上返回，等数据到达再通知函数，那么这是异步的路程。实际上同步与异步是针对应用程序与内核的交互而言的。同步过程中进程触发IO操作并等待或者轮询的去查看IO操作是否完成。异步过程中进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成。</li>
<li>阻塞和非阻塞：至于阻塞和非阻塞，则是函数是否让线程挂起不再往下执行。通常同步阻塞，异步非阻塞。简单理解为需要做一件事能不能立即得到返回应答，如果不能立即获得返回，需要等待，那就阻塞了，否则就可以理解为非阻塞。</li>
<li>区分阻塞和非阻塞只要区分函数调用之后是否挂起返回就可以了，区分异步和同步，则是函数调用之后，数据或条件满足之后如何通知函数。等待数据返回则是同步，通过回调则是异步。对于同步模型，主要是第一阶段处理方法不一样。而异步模型，两个阶段都不一样。</li>
</ul>
<h3 id="3、并发和并行"><a href="#3、并发和并行" class="headerlink" title="3、并发和并行"></a>3、并发和并行</h3><ul>
<li>并发：并发描述的是程序的组织结构。指程序要被设计成多个可独立执行的子任务。指的是<code>同一时间段</code>可执行多个任务。</li>
<li>并行：并行描述的是程序的执行状态。指多个任务同时被执行。指的是<code>同一时刻</code>可执行多个任务。</li>
<li>并发包含并行，是比并行跟广泛的概念。同一个CPU核心上多线程切换执行时并发，多个CPU核心上多进程同时执行是并行。</li>
</ul>
<h3 id="4、进程、线程和协程"><a href="#4、进程、线程和协程" class="headerlink" title="4、进程、线程和协程"></a>4、进程、线程和协程</h3><ul>
<li>进程：进程是一种古老而典型的上下文系统，每个进程有独立的地址空间，资源句柄，他们互相之间不发生干扰。每个进程在内核中会有一个数据结构进行描述，我们称其为进程描述符。这些描述符包含了系统管理进程所需的信息，并且放在一个叫做任务队列的队列里面。进程是系统资源分配的最小单位。进程的创建和销毁都是相对于系统资源,所以是一种比较昂贵的操作。进程是抢占式的争夺CPU运行自身,而CPU单核的情况下同一时间只能执行一个进程的代码,但是多进程的实现则是通过CPU飞快的切换不同进程,因此使得看上去就像是多个进程在同时进行。进程适用于CPU密集型的任务和IO密集型的任务。</li>
<li>线程：线程是一种轻量进程，是进程的一个实体，线程属于进程，多个线程共享进程的内存地址空间和资源。线程是CPU调度的最小单位。线程的切换需要操作系统调度，要陷入内核空间，由内核进行切换，程序无法控制。线程适用于IO密集型的任务。</li>
<li>协程：<code>协程是为非抢占式多任务产生子程序的计算机程序组件，协程允许不同入口点在不同位置暂停或开始执行程序。</code>从技术的角度来说，“协程就是你可以暂停执行的函数”。协程是属于线程的。协程程序是在线程里面运行的，因此协程又称微线程和纤程等，是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈，没有线程的上下文切换消耗。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。简单来说，<code>协程是一种允许在特定位置暂停或恢复的子程序</code>。协程适用于IO密集型的任务。</li>
</ul>
<h3 id="5、异步编程"><a href="#5、异步编程" class="headerlink" title="5、异步编程"></a>5、异步编程</h3><ul>
<li>回调：回调函数可以理解为是IO事件完毕后执行提前注册的回调函数。把I/O事件的等待和监听任务交给了操作系统，操作系统在知道I/O状态发生改变后，通过回调通知调用程序。</li>
<li>事件循环：事件循环 “是一种等待程序分配事件或消息的编程架构”。基本上来说事件循环就是，“当A发生时，执行B”。 事件循环提供一种循环机制，让你可以“在A发生时，执行B”。基本上来说事件循环就是监听当有什么发生时，同时事件循环也关心这件事并执行相应的代码。事件循环被认为是一种循环是因为它不停地收集事件并通过循环来查找如何应对这些事件。对 Python 来说，用来提供事件循环的 asyncio 被加入标准库中。asyncio 重点解决网络服务中的问题，事件循环在这里将来自socket的 I/O 已经准备好读和/或写作为“当A发生时”（通过selectors模块）。</li>
<li>异步编程：异步编程是一种IO模型，异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程。不论什么编程语言，但凡要做异步编程，<code>事件循环+回调</code>这种模式是逃不掉的，尽管它可能用的不是epoll，也可能不是while循环。但是由于基于回调的异步模型会出现回调地狱、错误处理困难、堆栈撕裂等问题，所以Python在事件循环+回调的基础上衍生出了基于协程的解决方案。</li>
<li><code>在Python中协程和事件循环一起使用构成了异步编程。</code>Python 3.4 以后通过标准库 asyncio 获得了事件循环的特性（主要通过selectors模块来实现）。</li>
</ul>
<h2 id="二、Python异步编程进化史"><a href="#二、Python异步编程进化史" class="headerlink" title="二、Python异步编程进化史"></a>二、Python异步编程进化史</h2><h3 id="1、生成器yield"><a href="#1、生成器yield" class="headerlink" title="1、生成器yield"></a>1、生成器yield</h3><ul>
<li><code>协程是为非抢占式多任务产生子程序的计算机程序组件，协程允许不同入口点在不同位置暂停或开始执行程序。</code>从技术的角度来说，“协程就是你可以暂停执行的函数”。是不是和生成器的特性很像？</li>
<li>生成器第一次在PEP 255中提出（那时也把它成为迭代器，因为它实现了迭代器协议）。生成器允许创建一个在计算下一个值时不会浪费内存空间的迭代器。让函数遇到<code>yield</code>表达式时暂停执行，并且能够在后面重新执行，这对于减少内存使用、生成无限序列非常有用。</li>
<li>为了支持用生成器做简单的协程，Python 2.5 对生成器进行了增强(PEP 342)。有了PEP 342的加持，生成器可以通过<code>yield</code>暂停执行和向外返回数据，也可以通过<code>send()</code>向生成器内发送数据，还可以通过<code>throw()</code>向生成器内抛出异常以便随时终止生成器的运行。</li>
<li><p>yield关键字产生的协程是如何运行的，如下图：<br><img src="/2019/02/16/Python异步编程详解/2.jpg" alt="2.jpg"></p>
</li>
<li><p>从上图可以看出，调用生成器函数时，并不会立即执行函数，而是返回一个生成器对象，然后通过next()函数触发生成器，函数执行到yield表达式时会暂停，并将yield后面的值返回给触发者，通过send()函数将值从外部传入到生成器内部，生成器继续执行，直到遇到下一个yield表达式，当生成器函数所有的代码执行完没有遇到下一个yield，就会抛出异常，如果对生成器使用for循环，for循环会自动处理异常。</p>
</li>
<li>其实next()和send()在一定意义上作用是相似的，区别是send()可以传递yield表达式的值进去，而next()不能传递特定的值，只能传递None进去。因此，我们可以看做c.next() 和 c.send(None) 作用是一样的。 因此也可以不通过next()函数，通过send(None)来触发生成器，使用send()触发第一次传入的参数必须是None，否则会报错，因为第一次触发没有yield语句来接收其他非None的值。</li>
<li>send(msg)和next()都会有返回值，返回值是下一个yield表达式的参数，比如说yield 5 则返回5 。另外，在一个生成器中，如果没有 return，则默认执行至函数完毕，如果在执行过程中 return，则直接抛出 StopIteration 终止迭代。</li>
</ul>
<h3 id="2、yield-from"><a href="#2、yield-from" class="headerlink" title="2、yield from"></a>2、yield from</h3><ul>
<li>Python3.3版本的PEP 380中添加了yield from语法。允许一个generator生成器将其部分操作委派给另一个生成器。其产生的主要动力在于使生成器能够很容易分为多个拥有send和throw方法的子生成器，像一个大函数可以分为多个子函数一样简单。Python的生成器是协程coroutine的一种形式，但它的局限性在于只能向它的直接调用者yield值。这意味着那些包含yield的代码不能想其他代码那样被分离出来放到一个单独的函数中。这也正是yield from要解决的。</li>
<li>yield from 后面需要加的是可迭代对象，它可以是普通的可迭代对象，也可以是迭代器，甚至是生成器。</li>
<li>虽然yield from主要设计用来向子生成器委派操作任务，但yield from可以向任意的迭代器委派操作。<h4 id="2-1、替代for循环"><a href="#2-1、替代for循环" class="headerlink" title="2.1、替代for循环"></a>2.1、替代for循环</h4></li>
<li>对于简单的迭代器，<code>yield from iterable</code>本质上等于<code>for item in iterable: yield item</code>的缩写版：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#使用yield语句</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'AB'</span>:</div><div class="line"><span class="meta">... </span><span class="keyword">yield</span> c</div><div class="line"><span class="meta">... </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</div><div class="line"><span class="meta">... </span><span class="keyword">yield</span> i</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen())</div><div class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="number">1</span>, <span class="number">2</span>]</div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="comment">#使用yield from实现相同的功能</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span><span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">'AB'</span></div><div class="line"><span class="meta">... </span><span class="keyword">yield</span> <span class="keyword">from</span> range(<span class="number">1</span>, <span class="number">3</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen())</div><div class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="number">1</span>, <span class="number">2</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-2、打开双通道"><a href="#2-2、打开双通道" class="headerlink" title="2.2、打开双通道"></a>2.2、打开双通道</h4><ul>
<li>先明确几个概念：<ul>
<li>调用方：调用委派生成器的客户端（调用方）代码</li>
<li>委托生成器：包含yield from表达式的生成器函数</li>
<li>子生成器：yield from后面加的生成器函数</li>
</ul>
</li>
<li>但是yield from不仅仅如此，还有更加强大的功能，不同于普通的循环，<code>yield from允许子生成器直接从调用者接收其发送的信息或者抛出调用时遇到的异常，并且返回给委派生产器一个值。</code></li>
<li>代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</div><div class="line"></div><div class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</div><div class="line"></div><div class="line"><span class="comment"># the subgenerator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></div><div class="line">    total = <span class="number">0.0</span></div><div class="line">    count = <span class="number">0</span></div><div class="line">    average = <span class="keyword">None</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        term = <span class="keyword">yield</span></div><div class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        total += term</div><div class="line">        count += <span class="number">1</span></div><div class="line">        average = total / count</div><div class="line">    <span class="keyword">return</span> Result(count, average)</div><div class="line"></div><div class="line"><span class="comment"># the delegating generator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="comment">#只有当生成器averager()结束，才会返回结果给results赋值</span></div><div class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></div><div class="line">    results = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</div><div class="line">        group = grouper(results, key)</div><div class="line">        next(group)</div><div class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</div><div class="line">            group.send(value)</div><div class="line">        group.send(<span class="keyword">None</span>)</div><div class="line">    report(results)</div><div class="line"></div><div class="line"><span class="comment">#如果不使用yield from，仅仅通过yield实现相同的效果，如下：</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main2</span><span class="params">(data)</span>:</span></div><div class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</div><div class="line">        aver = averager()</div><div class="line">        next(aver)</div><div class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</div><div class="line">            aver.send(value)</div><div class="line">        <span class="keyword">try</span>: <span class="comment">#通过异常接受返回的数据</span></div><div class="line">            aver.send(<span class="keyword">None</span>)</div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            result = e.value</div><div class="line">            print(result)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">report</span><span class="params">(results)</span>:</span></div><div class="line">    <span class="keyword">for</span> key, result <span class="keyword">in</span> sorted(results.items()):</div><div class="line">        group, unit = key.split(<span class="string">';'</span>)</div><div class="line">        print(<span class="string">'&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&#123;&#125;'</span>.format(result.count, group, result.average, unit))</div><div class="line"></div><div class="line">data = &#123;</div><div class="line">    <span class="string">'girls;kg'</span>:[<span class="number">40.9</span>, <span class="number">38.5</span>, <span class="number">44.3</span>, <span class="number">42.2</span>, <span class="number">45.2</span>, <span class="number">41.7</span>, <span class="number">44.5</span>, <span class="number">38.0</span>, <span class="number">40.6</span>, <span class="number">44.5</span>],</div><div class="line">    <span class="string">'girls;m'</span>:[<span class="number">1.6</span>, <span class="number">1.51</span>, <span class="number">1.4</span>, <span class="number">1.3</span>, <span class="number">1.41</span>, <span class="number">1.39</span>, <span class="number">1.33</span>, <span class="number">1.46</span>, <span class="number">1.45</span>, <span class="number">1.43</span>],</div><div class="line">    <span class="string">'boys;kg'</span>:[<span class="number">39.0</span>, <span class="number">40.8</span>, <span class="number">43.2</span>, <span class="number">40.8</span>, <span class="number">43.1</span>, <span class="number">38.6</span>, <span class="number">41.4</span>, <span class="number">40.6</span>, <span class="number">36.3</span>],</div><div class="line">    <span class="string">'boys;m'</span>:[<span class="number">1.38</span>, <span class="number">1.5</span>, <span class="number">1.32</span>, <span class="number">1.25</span>, <span class="number">1.37</span>, <span class="number">1.48</span>, <span class="number">1.25</span>, <span class="number">1.49</span>, <span class="number">1.46</span>],</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main(data)</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2019/02/16/Python异步编程详解/3.jpg" alt="3.jpg"></p>
<ul>
<li>总结如下：<ul>
<li>1.迭代器（即可指子生成器）产生的值直接返还给调用者</li>
<li>2.任何使用send()方法发给委派生产器（即外部生产器）的值被直接传递给迭代器。如果send值是None，则调用迭代器next()方法；如果不为None，则调用迭代器的send()方法。如果对迭代器的调用产生StopIteration异常，委派生产器恢复继续执行yield from后面的语句；若迭代器产生其他任何异常，则都传递给委派生产器。</li>
<li>3.除了GeneratorExit 异常外的其他抛给委派生产器的异常，将会被传递到迭代器的throw()方法。如果迭代器throw()调用产生了StopIteration异常，委派生产器恢复并继续执行，其他异常则传递给委派生产器。</li>
<li>4.如果GeneratorExit异常被抛给委派生产器，或者委派生产器的close()方法被调用，如果迭代器有close()的话也将被调用。如果close()调用产生异常，异常将传递给委派生产器。否则，委派生产器将抛出GeneratorExit 异常。</li>
<li>5.当迭代器结束并抛出异常时，yield from表达式的值是其StopIteration 异常中的第一个参数。</li>
<li>6.一个生成器中的return expr语句将会从生成器退出并抛出 StopIteration(expr)异常。</li>
</ul>
</li>
</ul>
<h3 id="3、asyncio框架"><a href="#3、asyncio框架" class="headerlink" title="3、asyncio框架"></a>3、asyncio框架</h3><ul>
<li>用yield from改进基于生成器的协程，代码抽象程度更高。至此，Python已经具备异步编程的基础能力，于是Python语言开发者们充分利用yield from，在Python 3.4 试验性引入的异步I/O框架asyncio（PEP 3156），提供了基于协程做异步I/O编写单线程并发代码的基础设施。</li>
<li>Python 3.4 中，<code>asyncio.coroutine</code>修饰器用来标记作为协程的函数，这里的协程是和asyncio及其事件循环一起使用的。这赋予了Python第一个对于协程的明确定义：实现了PEP 342添加到生成器中的这一方法的对象，并通过<code>collections.abc.Coroutine这一抽象基类</code>表征的对象。这意味着突然之间所有实现了协程接口的生成器，即便它们并不是要以协程方式应用，都符合这一定义。为了修正这一点，asyncio 要求所有要用作协程的生成器必须由asyncio.coroutine修饰。</li>
<li>有了对协程明确的定义（能够匹配生成器所提供的API），你可以对任何asyncio.Future对象使用 yield from，从而将其传递给事件循环，暂停协程的执行来等待某些事情的发生（ future 对象并不重要，只是asyncio细节的实现）。一旦 future 对象获取了事件循环，它会一直在那里监听，直到完成它需要做的一切。当 future 完成自己的任务之后，事件循环会察觉到，暂停并等待在那里的协程会通过send()方法获取future对象的返回值并开始继续执行。</li>
<li><p>在 Python 3.4 中，用于异步编程并被标记为协程的函数看起来是这样的：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line"><span class="comment"># Borrowed from http://curio.readthedocs.org/en/latest/tutorial.html.</span></div><div class="line">@asyncio.coroutine</div><div class="line">def countdown(number, n):</div><div class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</div><div class="line">        <span class="built_in">print</span>(<span class="string">'T-minus'</span>, n, <span class="string">'(&#123;&#125;)'</span>.format(number))</div><div class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</div><div class="line">        n -= <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">loop</span> = asyncio.get_event_loop()</div><div class="line">tasks = [</div><div class="line">    asyncio.ensure_future(countdown(<span class="string">"A"</span>, <span class="number">2</span>)),</div><div class="line">    asyncio.ensure_future(countdown(<span class="string">"B"</span>, <span class="number">3</span>))]</div><div class="line"><span class="keyword">loop</span>.run_until_complete(asyncio.wait(tasks))</div><div class="line"><span class="keyword">loop</span>.close()</div></pre></td></tr></table></figure>
</li>
<li><p>虽然发展到 Python 3.4 时有了yield from的加持让协程更容易了，但是由于协程在Python中发展的历史包袱所致，迭代器的过度重载，使用生成器实现协程功能有很多缺点：</p>
<ul>
<li>协程与常规的生成器在相同语法时用以混淆，尤其是对心开发者而言。</li>
<li>一个函数是否是协程需要通过是否主体代码中使用了yield或者yield from语句进行检测，这样在重构代码中添加、去除过程中容易出现不明显的错误</li>
<li>异步调用的支持被yield支持的语法先定了，导致我们无法使用更多的语法特性，比如with和for语句。</li>
</ul>
</li>
<li>于是根据Python 3.5 Beta期间的反馈，进行了重新设计：明确的把协程从生成器里独立出来—原生协程现在拥有了自己完整的独立类型，而不再是一种新的生成器类型。</li>
</ul>
<h3 id="4、async-await-原生协程"><a href="#4、async-await-原生协程" class="headerlink" title="4、async/await 原生协程"></a>4、async/await 原生协程</h3><ul>
<li>Python设计者们在 3.5 中新增了async/await语法（PEP 492），将协程作为原生Python语言特性，并且将他们与生成器明确的区分开。它避免了生成器/协程中间的混淆，方便编写出不依赖于特定库的协程代码，称之为原生协程。async/await 和 yield from这两种风格的协程底层复用共同的实现，而且相互兼容。在Python 3.6 中asyncio库“转正”，不再是实验性质的，成为标准库的正式一员。</li>
<li>Python 3.5 添加了<code>types.coroutine</code>修饰器，也可以像 asyncio.coroutine 一样将生成器标记为协程。你可以用 async def 来定义一个协程函数，虽然这个函数不能包含任何形式的 yield 语句；只有 return 和 await 可以从协程中返回值。</li>
<li><p>下面的新语法用于声明原生协程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">(db)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
</li>
<li><p>协程的主要属性包括：</p>
<ul>
<li><code>async def函数始终为协程，即使它不包含await表达式。</code></li>
<li><code>如果在async函数中使用yield或者yield from表达式会产生SyntaxError错误。</code></li>
<li>在内部，引入了两个新的代码对象标记：<ul>
<li>CO_COROUTINE用于标记原生协程（和新语法一起定义）</li>
<li>CO_ITERABLE_COROUTINE用于标记基于生成器的协程，兼容原生协程。(通过types.coroutine()函数设置)</li>
</ul>
</li>
<li>常规生成器在调用时会返回一个genertor对象，同理，协程在调用时会返回一个coroutine对象。</li>
<li>协程不再抛出StopIteration异常，而是替代为RuntimeError。常规生成器实现类似的行为需要进行引入<strong>future</strong>(PEP-3156)</li>
<li>当协程进行垃圾回收时，一个从未被await的协程会抛出RuntimeWarning异常</li>
</ul>
</li>
<li><p>types.coroutine()：<code>在types模块中新添加了一个函数coroutine(fn)用于asyncio中基于生成器的协程与本PEP中引入的原生携协程互通。</code>使用它，“生成器实现的协程”和“原生协程”之间可以进行互操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@types.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_data</span><span class="params">(db)</span>:</span></div><div class="line">    data = <span class="keyword">yield</span> <span class="keyword">from</span> read_data(db)</div><div class="line">    ...</div></pre></td></tr></table></figure>
</li>
<li><p>这个函数将生成器函数对象设置CO_ITERABLE_COROUTINE标记，将返回对象变为coroutine对象。如果fn不是一个生成器函数，那么它会对其进行封装。如果它返回一个生成器，那么它会封装一个awaitable代理对象。</p>
</li>
<li>注意：CO_COROUTINE标记不能通过types.coroutine()进行设置，这就可以将新语法定义的原生协程与基于生成器的协程进行区分。</li>
<li>await与yield from相似，await关键字的行为类似标记了一个断点，挂起协程的执行直到其他awaitable对象完成并返回结果数据。它复用了yield from的实现，并且添加了额外的验证参数。await只接受以下之一的awaitable对象：<ul>
<li>一个原生协程函数返回的原生协程对象。</li>
<li>一个使用types.coroutine()修饰器的函数返回的基于生成器的协程对象。</li>
<li>一个包含返回迭代器的<strong>await</strong>方法的对象。</li>
</ul>
</li>
<li>协程链：协程的一个关键特性是它们可以组成协程链，就像函数调用链一样，一个协程对象是awaitable的，因此其他协程可以await另一个协程对象。</li>
<li>任意一个yield from链都会以一个yield结束，这是Future实现的基本机制。因此，协程在内部中是一种特殊的生成器。<code>每个await最终会被await调用链条上的某个yield语句挂起。</code></li>
<li><code>关于基于生成器的协程和async定义的原生协程之间的差异，关键点是只有基于生成器的协程可以真正的暂停执行并强制性返回给事件循环。所以每个await最终会被await调用链条上的某个由types.coroutine()装饰的包含yield语句的协程函数挂起。</code></li>
<li>为了启用协程的这一特点，一个新的魔术方法<code>__await__</code>被添加进来。在asyncio中，对于对象在await语句启用Future对象只需要添加<strong>await</strong> = <strong>iter</strong>这行到asyncio.Future类中。带有<strong>await</strong>方法的对象也叫做Future-like对象。</li>
<li>另外还新增了异步上下文管理 async with 和异步迭代器 async for。异步生成器和异步推导式都让迭代变得并发，他们所做的只是提供同步对应的外观，但是有问题的循环能够放弃对事件循环的控制，以便运行其他协程。</li>
<li>更多有关原生协程的实现细节，可参考PEP 0492。</li>
<li>关于何时以及如何能够和不能使用async / await，有一套严格的规则：<ul>
<li>使用async关键字创建一个协程函数，里面包含await或者return，调用协程函数，必须使用await获得函数返回结果。</li>
<li>在async异步函数中使用yield并不常见，这会创建一个异步生成器，可以使用async for来迭代异步生成器。</li>
<li>在async异步函数中使用yield from会抛出语法错误。同样在普通函数中使用await也是语法错误。</li>
</ul>
</li>
</ul>
<h3 id="5、将-async-await-看做异步编程的-API"><a href="#5、将-async-await-看做异步编程的-API" class="headerlink" title="5、将 async/await 看做异步编程的 API"></a>5、将 async/await 看做异步编程的 API</h3><ul>
<li>Python的核心开发者David指出：<code>async/await 实际上是异步编程的 API，人们不应该将async/await等同于asyncio，而应该将asyncio看作是一个利用async/await API 进行异步编程的框架。async/await 的设计意图就是为了让其足够灵活从而不需要依赖asyncio或者仅仅是为了适应这一框架而扭曲关键的设计决策。</code></li>
<li>下面是将async/await 看做异步编程的 API的一个完整的异步编程的例子，包括事件循环，三个countdown()协程函数并发运行：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">import</span> heapq</div><div class="line"><span class="keyword">import</span> types</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span></div><div class="line">    <span class="string">"""相当于asyncio.Task，存储协程和要执行的时间"""</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, wait_until, coro)</span>:</span></div><div class="line">        self.coro = coro</div><div class="line">        self.waiting_until = wait_until</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.waiting_until == other.waiting_until</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.waiting_until &lt; other.waiting_until</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepingLoop</span>:</span></div><div class="line">    <span class="string">"""一个事件循环，每次执行最先需要执行的协程，时间没到就阻塞等待，相当于asyncio中的事件循环"""</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *coros)</span>:</span></div><div class="line">        self._new = coros</div><div class="line">        self._waiting = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 启动所有的协程</span></div><div class="line">        <span class="keyword">for</span> coro <span class="keyword">in</span> self._new:</div><div class="line">            print(coro)</div><div class="line">            wait_for = coro.send(<span class="keyword">None</span>)</div><div class="line">            heapq.heappush(self._waiting, Task(wait_for, coro))</div><div class="line">        <span class="comment"># 保持运行，直到没有其他事情要做</span></div><div class="line">        <span class="keyword">while</span> self._waiting:</div><div class="line">            now = datetime.datetime.now()</div><div class="line">            <span class="comment"># 每次取出最先执行的协程</span></div><div class="line">            task = heapq.heappop(self._waiting)</div><div class="line">            <span class="keyword">if</span> now &lt; task.waiting_until:</div><div class="line">                <span class="comment"># 阻塞等待指定的休眠时间</span></div><div class="line">                delta = task.waiting_until - now</div><div class="line">                time.sleep(delta.total_seconds())</div><div class="line">                print(task.coro, delta.total_seconds())</div><div class="line">                now = datetime.datetime.now()</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                <span class="comment"># 恢复不需要等待的协程</span></div><div class="line">                wait_until = task.coro.send(now)</div><div class="line">                heapq.heappush(self._waiting, Task(wait_until, task.coro))</div><div class="line">            <span class="keyword">except</span> StopIteration:</div><div class="line">                <span class="comment"># 捕捉协程结束的抛出异常</span></div><div class="line">                <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="meta">@types.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(seconds)</span>:</span></div><div class="line">    <span class="string">"""暂停一个协程指定时间，可把他当做asyncio.sleep()"""</span></div><div class="line">    now = datetime.datetime.now()</div><div class="line">    wait_until = now + datetime.timedelta(seconds=seconds)</div><div class="line">    actual = <span class="keyword">yield</span> wait_until</div><div class="line">    <span class="keyword">return</span> actual - now</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(label, length, *, delay=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="string">"""协程函数，实现具体的任务"""</span></div><div class="line">    print(label, <span class="string">'waiting'</span>, delay, <span class="string">'seconds before starting countdown'</span>)</div><div class="line">    delta = <span class="keyword">await</span> sleep(delay)</div><div class="line">    print(label, <span class="string">'starting after waiting'</span>, delta)</div><div class="line">    <span class="keyword">while</span> length:</div><div class="line">        print(label, <span class="string">'T-minus'</span>, length)</div><div class="line">        waited = <span class="keyword">await</span> sleep(<span class="number">1</span>)</div><div class="line">        length -= <span class="number">1</span></div><div class="line">    print(label, <span class="string">'lift-off!'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""启动事件循环，运行三个协程"""</span></div><div class="line">    loop = SleepingLoop(countdown(<span class="string">'A'</span>, <span class="number">5</span>), countdown(<span class="string">'B'</span>, <span class="number">3</span>, delay=<span class="number">2</span>),</div><div class="line">                        countdown(<span class="string">'C'</span>, <span class="number">4</span>, delay=<span class="number">1</span>))</div><div class="line">    start = datetime.datetime.now()</div><div class="line">    loop.run_until_complete()</div><div class="line">    print(<span class="string">'Total elapsed time is'</span>, datetime.datetime.now() - start)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6、总结Python异步编程版本细节"><a href="#6、总结Python异步编程版本细节" class="headerlink" title="6、总结Python异步编程版本细节"></a>6、总结Python异步编程版本细节</h3><ul>
<li>Python 2.5：增强生成器yield。</li>
<li>Python 3.3：引入yield from表达式。</li>
<li>Python 3.4：asyncio作为具有临时API的状态引入Python标准库中。</li>
<li>Python 3.5：async和await成为Python语法的一部分，用于表示和协程，但它们还不是保留关键字。 </li>
<li>Python 3.6：引入异步生成器和异步推导式，asyncio的API被宣布为稳定版本而非临时。</li>
<li>Python 3.7：async和await成为保留关键字，它们旨在替换asyncio.coroutine()装饰器。 asyncio.run()被引入asyncio包，简化协程运行，其中还包括许多其他功能。</li>
</ul>
<h2 id="三、asyncio工作原理"><a href="#三、asyncio工作原理" class="headerlink" title="三、asyncio工作原理"></a>三、asyncio工作原理</h2><ul>
<li>前面提到异步编程是通过<code>事件循环+回调</code>这种模式实现的，但是这种模式会出现回调地狱、错误处理困难、堆栈撕裂等问题，所以Python在事件循环+回调的基础上衍生出了基于协程的解决方案，并不是没有回调，而是巧妙的通过Future对象将回调隐藏其中，方便使用和理解。</li>
<li>asyncio框架中有三个主要组件：<code>协程对象、事件循环和Future&amp;Task对象。</code><h3 id="协程对象"><a href="#协程对象" class="headerlink" title="协程对象"></a>协程对象</h3></li>
<li>协程对象：指一个使用async关键字定义的异步函数，是需要执行的任务，它的调用不会立即执行函数，而是会返回一个协程对象。协程不能直接运行，协程对象需要注册到事件循环，由事件循环调用。</li>
<li>有两种方法可以从协程读取异步函数的输出：<ul>
<li>1、第一种方法是使用await关键字，这只能在异步函数中使用，等待协程终止并返回结果。</li>
<li>2、第二种方法是将协程添加到事件循环中。</li>
</ul>
</li>
<li>在Python中编写异步函数时要记住的一件事是，在def之前使用了async关键字并不意味着你的异步函数将同时运行。如果采用普通函数并在其前面添加async，则事件循环将运行函数而不会中断，因为你没有指定允许循环中断你的函数以运行另一个协同程序的位置。指定允许事件循环中断运行的位置非常简单，每次使用关键字await等待事件循环都可以停止运行你的函数并切换到运行另一个注册到循环的协同程序。</li>
</ul>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><ul>
<li>事件循环是执行我们的异步代码并决定如何在异步函数之间切换的对象。如果某个协程在等待某些资源，我们需要暂停它的执行，在事件循环中注册这个事件，以便当事件发生的时候，能再次唤醒该协程的执行。 </li>
<li>运行异步函数我们首先需要创建一个协程，然后创建future或task对象，将它们添加到事件循环中，到目前为止，我们的异步函数中没有任何代码被执行过，只有调用loop.run_until_completed启动事件循环，才会开始执行future或task对象，loop.run_until_completed会阻塞程序直到所有的协程对象都执行完毕。</li>
<li><p>流程如下图：<br><img src="/2019/02/16/Python异步编程详解/4.png" alt="4.png"></p>
</li>
<li><p>1、事件循环是在线程中执行</p>
</li>
<li>2、从队列中取得任务</li>
<li>3、每个任务在协程中执行下一步动作</li>
<li>4、如果在一个协程中调用另一个协程（await <coroutine_name>），会触发上下文切换，挂起当前协程，并保存现场环境（变量，状态），然后载入被调用协程</coroutine_name></li>
<li>5、如果协程的执行到阻塞部分（阻塞I/O，Sleep），当前协程会挂起，并将控制权返回到线程的消息循环中，然后消息循环继续从队列中执行下一个任务．．．以此类推</li>
<li>6、队列中的所有任务执行完毕后，消息循环返回第一个任务</li>
</ul>
<h3 id="Future-amp-Task对象"><a href="#Future-amp-Task对象" class="headerlink" title="Future &amp; Task对象"></a>Future &amp; Task对象</h3><h4 id="Future对象"><a href="#Future对象" class="headerlink" title="Future对象"></a>Future对象</h4><ul>
<li>Future对象：Future对象封装了一个未来会被计算的可调用的异步执行对象，他们能被放入队列，他们的状态、结果或者异常能被查询。 Future对象有一个<code>result</code>属性，用于存放未来的执行结果。还有个<code>set_result()</code>方法，是用于设置<code>result</code>的，并且会在给<code>result</code>绑定值以后运行事先给Future对象添加的回调。回调是通过Future对象的<code>add_done_callback()</code>方法添加的。</li>
<li><p>重要的是Future对象不能被我们创建，只能被异步框架创建，有两种方法：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 该函数在 Python 3.7 中被加入，更加高层次的函数，返回Task对象</span></div><div class="line"><span class="attr">future1</span> = asyncio.create_task(my_coroutine)</div><div class="line"><span class="comment"># 在Python 3.7 之前，是更加低级的函数，返回Future对象或者Task对象</span></div><div class="line"><span class="attr">future2</span> = asyncio.ensure_future(my_coroutine)</div></pre></td></tr></table></figure>
</li>
<li><p>第一种方法在循环中添加一个协程并返回一个task对象，task对象是future的子类型。第二种方法非常相似，当传入协程对象时返回一个Task对象，唯一的区别是它也可以接受Future对象或Task对象，在这种情况下它不会做任何事情并且返回Future对象或者Task对象不变。</p>
</li>
<li>Future对象有几个状态：<ul>
<li>Pending：就绪</li>
<li>Running：运行</li>
<li>Done：完成</li>
<li>Cancelled：取消</li>
</ul>
</li>
<li>创建Future对象的时候，状态为pending，事件循环调用执行的时候就是running，调用完毕就是done，如果需要取消Future对象的调度执行，可调用Future对象的cancel()函数。</li>
<li>除此之外，Future对象还有下面一些常用的方法：<ul>
<li>result()：立即返回Future对象运行结果或者抛出执行时的异常，没有timeout参数，如果Future没有完成，不会阻塞等待结果，而是直接抛出InvalidStateError异常。最好的方式是通过await获取运行结果，await会自动等待Future完成返回结果，也不会阻塞事件循环，因为在asyncio中，await被用来将控制权返回给事件循环。</li>
<li>done()：非阻塞的返回Future对象是否成功取消或者运行结束或被设置异常，而不是查看future是否已经执行完成。</li>
<li>cancelled()：判断Future对象是否被取消。</li>
<li>add_done_callback()：传入一个可回调对象，当Future对象done时被调用。</li>
<li>exception()：获取Future对象中的异常信息，只有当Future对象done时才会返回。</li>
<li>get_loop()：获取当前Future对象绑定的事件循环。</li>
</ul>
</li>
<li><p>需要注意的是，当在协程内部引发未处理的异常时，它不会像正常的同步编程那样破坏我们的程序，相反，它存储在future内部，如果在程序退出之前没有处理异常，则会出现以下错误：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Task</span> <span class="keyword">exception</span> was never retrieved</div></pre></td></tr></table></figure>
</li>
<li><p>有两种方法可以解决此问题，在访问future对象的结果时捕获异常或调用future对象的异常函数：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="comment"># 调用结果时捕获异常</span></div><div class="line">    my_promise.result()</div><div class="line"><span class="keyword">catch</span> <span class="keyword">Exception</span>:</div><div class="line">    pass</div><div class="line"></div><div class="line"><span class="comment"># 获取在协程执行过程中抛出的异常</span></div><div class="line">my_promise.<span class="keyword">exception</span>()</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Task对象"><a href="#Task对象" class="headerlink" title="Task对象"></a>Task对象</h4><ul>
<li>Task对象：Task对象是Future对象的子类型，coroutine和Future联系在一起。与 Future 不同的是它包含了一个将要执行的协程，从而组成一个需要被调度的任务，<code>Task类用来管理协同程序运行的状态，负责在事件循环中执行一个协程对象，是一个协程驱动器，用来恢复继续执行生成器，管理生成器的状态。</code></li>
<li>Task对象被用来在事件循环中运行协程。如果一个协程在等待一个Future对象，Task对象会挂起该协程的执行并等待该Future对象完成。当该Future对象完成，被暂停的协程将恢复执行。事件循环使用协作调度: 一个事件循环每次运行一个Task对象。当一个Task对象等待一个Future对象完成时，该事件循环会运行其他Task、回调或执行IO操作。</li>
<li>使用高层级的asyncio.create_task()函数来创建Task对象，也可用低层级的loop.create_task()或ensure_future()函数。不建议手动实例化 Task 对象。</li>
</ul>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><ul>
<li><p>这里举一个 Python 官方文档 的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio  </div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(x, y)</span>:</span>  </div><div class="line">    print(<span class="string">"Compute &#123;&#125; + &#123;&#125;..."</span>.format(x, y))</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2.0</span>)</div><div class="line">    <span class="keyword">return</span> x+y</div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">print_sum</span><span class="params">(x, y)</span>:</span>  </div><div class="line">    result = <span class="keyword">await</span> compute(x, y)</div><div class="line">    print(<span class="string">"&#123;&#125; + &#123;&#125; = &#123;&#125;"</span>.format(x, y, result))</div><div class="line"></div><div class="line">start = time.time()  </div><div class="line">loop = asyncio.get_event_loop()  </div><div class="line">tasks = [  </div><div class="line">    asyncio.ensure_future(print_sum(<span class="number">0</span>, <span class="number">0</span>)),</div><div class="line">    asyncio.ensure_future(print_sum(<span class="number">1</span>, <span class="number">1</span>)),</div><div class="line">    asyncio.ensure_future(print_sum(<span class="number">2</span>, <span class="number">2</span>)),</div><div class="line">]</div><div class="line">loop.run_until_complete(asyncio.wait(tasks))  </div><div class="line">loop.close()  </div><div class="line">print(<span class="string">"Total elapsed time &#123;&#125;"</span>.format(time.time() - start))</div></pre></td></tr></table></figure>
</li>
<li><p>上面的代码的执行流程是：<br><img src="/2019/02/16/Python异步编程详解/5.png" alt="5.png"></p>
</li>
<li><p>详细的流程应该是这样的：<br><img src="/2019/02/16/Python异步编程详解/6.png" alt="6.png"></p>
</li>
<li><p>详细代码步骤可参看下面资料：</p>
<ul>
<li><a href="http://python.jobbole.com/88291/" target="_blank" rel="external">深入理解 Python 异步编程(上)</a></li>
<li><a href="http://www.qingpingshan.com/jb/python/322500.html" target="_blank" rel="external">Python asyncio详解</a></li>
<li><a href="http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html" target="_blank" rel="external">A Web Crawler With asyncio Coroutines</a></li>
</ul>
</li>
</ul>
<h2 id="四、asyncio使用详解"><a href="#四、asyncio使用详解" class="headerlink" title="四、asyncio使用详解"></a>四、asyncio使用详解</h2><h3 id="1、基本使用"><a href="#1、基本使用" class="headerlink" title="1、基本使用"></a>1、基本使用</h3><ul>
<li>协程完整的工作流程是这样：<ul>
<li>1、定义/创建协程对象</li>
<li>2、将协程转为task任务</li>
<li>3、定义事件循环对象容器</li>
<li>4、将task任务扔进事件循环对象中触发运行</li>
</ul>
</li>
<li>协程：协程通过 async/await 语法进行声明，是编写异步应用的推荐方式。注意：简单地调用一个协程并不会将其加入执行队列。</li>
<li>要真正运行一个协程，asyncio 提供了三种主要机制：<ul>
<li>1、<code>asyncio.run() 函数用来运行最高层级的入口点协程函数。</code>该函数运行传入的协程，负责管理asyncio事件循环并结束异步生成器。当有其他asyncio事件循环在同一线程中运行时，此函数不能被调用。如果debug为True，事件循环将以调试模式运行。该函数总是会创建一个新的事件循环并在结束时关闭。它应当被用作asyncio程序的主入口点，理想情况下应当只被调用一次。该函数在Python 3.7被引入，会隐式处理事件循环。</li>
<li>2、<code>使用await关键字等待一个协程。</code></li>
<li>3、<code>asyncio.create_task()函数用来并发运行作为asyncio任务的多个协程。</code>当一个协程通过asyncio.create_task()等函数被打包为一个Task对象，该协程将自动排入队列准备立即运行。然后通过await或者asyncio.run()自动运行该任务。该函数在Python 3.7中被加入。在Python 3.7之前，可以改用低层级的asyncio.ensure_future()函数。</li>
</ul>
</li>
<li><p>三种运行方式代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span><span class="params">(delay, what)</span>:</span></div><div class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</div><div class="line">    print(what)</div><div class="line">    <span class="keyword">return</span> delay</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 通过await等待运行，此时两个任务按顺序运行</span></div><div class="line">    result1 = <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">'hello'</span>)</div><div class="line">    result2 = <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">'world'</span>)</div><div class="line"></div><div class="line">    print(result1, result2)</div><div class="line"></div><div class="line">    task1 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">'hello2'</span>))</div><div class="line">    task2 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">'world2'</span>))</div><div class="line"></div><div class="line">    <span class="comment"># 通过asyncio.task()包装为task然后await等待运行，此时两个任务并发运行</span></div><div class="line">    result3 = <span class="keyword">await</span> task1</div><div class="line">    result4 = <span class="keyword">await</span> task2</div><div class="line">    print(result3, result4)</div><div class="line"></div><div class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 通过asyncio.run()函数运行</span></div><div class="line">asyncio.run(main())</div><div class="line"><span class="comment"># 下面相当于上面的asyncio.run()函数</span></div><div class="line"><span class="comment"># loop = asyncio.get_event_loop()</span></div><div class="line"><span class="comment"># try:</span></div><div class="line"><span class="comment">#     loop.run_until_complete(main())</span></div><div class="line"><span class="comment"># finally:</span></div><div class="line"><span class="comment">#     loop.close()</span></div></pre></td></tr></table></figure>
</li>
<li><p>可等待对象：如果一个对象可以在await语句中使用，那么它就是可等待对象。许多 asyncio API 都被设计为接受可等待对象。可等待对象有三种主要类型：<code>协程、Task对象和Future对象。</code></p>
</li>
<li>Future对象：Future对象是一种特殊的低层级可等待对象，表示一个异步操作的最终结果。当一个Future对象被等待，这意味着协程将保持等待直到该Future对象在其他地方操作完毕。在asyncio中需要Future对象以便允许通过async/await使用基于回调的代码。<code>通常情况下没有必要在应用层级的代码中创建Future对象。</code></li>
<li><code>asyncio.sleep()</code>：阻塞delay指定的秒数。如果指定了result，则当协程完成时将其返回给调用者。sleep()总是会挂起当前任务，以允许其他任务运行。</li>
<li><code>注意</code>：如果不在main()函数中await其他协程，其他协程可能来不及运行就被取消了。因为asyncio.run(main())调用的式是loop.run_until_complete(main())，在没有await的情况下，事件循环只关注main()函数一个协程的结束，而不管main()函数中的其他协程任务，没有await，其他协程任务可能在任务完成前被取消。如果需要获取当前待处理Task对象的列表，可以使用<code>asyncio.all_tasks()</code>函数，使用<code>asyncio.current_task()</code>函数获取当前运行的Task实例，如果没有正在运行的任务则返回None。</li>
</ul>
<h4 id="并发运行任务"><a href="#并发运行任务" class="headerlink" title="并发运行任务"></a>并发运行任务</h4><ul>
<li><code>asyncio.gather(*aws, loop=None, return_exceptions=False)</code>：并发运行aws序列中的可等待对象。如果aws中的某个可等待对象为协程，它将自动作为一个Task加入队列。如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。结果值的顺序与aws中可等待对象的顺序一致。</li>
<li>代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(name, number)</span>:</span></div><div class="line">    f = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number + <span class="number">1</span>):</div><div class="line">        print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: Compute factorial(<span class="subst">&#123;i&#125;</span>)..."</span>)</div><div class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</div><div class="line">        f *= i</div><div class="line">    print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: factorial(<span class="subst">&#123;number&#125;</span>) = <span class="subst">&#123;f&#125;</span>"</span>)</div><div class="line">    <span class="keyword">return</span> f</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 并发运行三个任务</span></div><div class="line">    result = <span class="keyword">await</span> asyncio.gather(</div><div class="line">        factorial(<span class="string">"A"</span>, <span class="number">5</span>),</div><div class="line">        factorial(<span class="string">"B"</span>, <span class="number">3</span>),</div><div class="line">        factorial(<span class="string">"C"</span>, <span class="number">4</span>),</div><div class="line">    )</div><div class="line"></div><div class="line">    print(result)</div><div class="line"></div><div class="line">asyncio.run(main())</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="等待任务"><a href="#等待任务" class="headerlink" title="等待任务"></a>等待任务</h4><ul>
<li><code>asyncio.wait(aws, *, loop=None, timeout=None, return_when=ALL_COMPLETED)</code>：并发运行aws指定的可等待对象并阻塞线程直到满足return_when指定的条件。如果aws中的某个可等待对象为协程，它将自动作为任务加入日程。直接向wait()传入协程对象已弃用，因为这会导致令人迷惑的行为。返回两个Task/Future集合: (done, pending)，（已完成的，未完成的）</li>
<li><p>代码示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(name, number)</span>:</span></div><div class="line">    f = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number + <span class="number">1</span>):</div><div class="line">        print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: Compute factorial(<span class="subst">&#123;i&#125;</span>)..."</span>)</div><div class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</div><div class="line">        f *= i</div><div class="line">    print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: factorial(<span class="subst">&#123;number&#125;</span>) = <span class="subst">&#123;f&#125;</span>"</span>)</div><div class="line">    <span class="keyword">return</span> f</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    tasks = list()</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">5</span>):</div><div class="line">        tasks.append(asyncio.create_task(factorial(<span class="string">"Task"</span> + str(i), i)))</div><div class="line"></div><div class="line">    done, pending = <span class="keyword">await</span> asyncio.wait(tasks)</div><div class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> done:</div><div class="line">        result = <span class="keyword">await</span> d</div><div class="line">        print(result)</div><div class="line"></div><div class="line">asyncio.run(main())</div></pre></td></tr></table></figure>
</li>
<li><p>return_when 指定此函数应在何时返回。它必须为以下常数之一：</p>
<ul>
<li>FIRST_COMPLETED：函数将在任意可等待对象结束或取消时返回。</li>
<li>FIRST_EXCEPTION：函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于 ALL_COMPLETED。</li>
<li>ALL_COMPLETED：函数将在所有可等待对象结束或取消时返回。默认是该参数。</li>
</ul>
</li>
<li><code>asyncio.wait_for(aw, timeout, *, loop=None)</code>：等待aw可等待对象完成，指定timeout秒数后超时。</li>
<li><code>asyncio.as_completed(aws, *, loop=None, timeout=None)</code>：并发地运行aws集合中的可等待对象。返回一个Future对象的迭代器。返回的每个Future对象代表来自剩余可等待对象集合的最早结果。</li>
</ul>
<h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><ul>
<li>可通过task.add_done_callback()方法给任务添加回调函数，当任务执行完成时会自动调用该函数并传入Task对象。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(task)</span>:</span></div><div class="line">    print(task, <span class="string">"done"</span>)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"hello"</span>)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    task = asyncio.create_task(hello())</div><div class="line">    task.add_done_callback(callback)</div><div class="line">    <span class="keyword">await</span> task</div><div class="line"></div><div class="line">asyncio.run(main())</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h3><ul>
<li>asyncio框架的队列设计的和queue模块的很类似。尽管asyncio模块的队列不是线程安全的，它们被设计为专门用于async/await代码。需要注意的是asyncio的队列没有timeout参数，可使用asyncio.wait_for()函数进行超时等待。</li>
<li><p>官方示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> itertools <span class="keyword">as</span> it</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">makeitem</span><span class="params">(size: int = <span class="number">5</span>)</span> -&gt; str:</span></div><div class="line">    <span class="keyword">return</span> os.urandom(size).hex()</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">randint</span><span class="params">(a: int, b: int)</span> -&gt; int:</span></div><div class="line">    <span class="keyword">return</span> random.randint(a, b)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">randsleep</span><span class="params">(a: int = <span class="number">1</span>, b: int = <span class="number">5</span>, caller=None)</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">    i = <span class="keyword">await</span> randint(a, b)</div><div class="line">    <span class="keyword">if</span> caller:</div><div class="line">        print(<span class="string">f"<span class="subst">&#123;caller&#125;</span> sleeping for <span class="subst">&#123;i&#125;</span> seconds."</span>)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(i)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(name: int, q: asyncio.Queue)</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">    <span class="string">"""生产者"""</span></div><div class="line">    n = <span class="keyword">await</span> randint(<span class="number">1</span>, <span class="number">5</span>)</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> it.repeat(<span class="keyword">None</span>, n): <span class="comment"># 同步添加任务</span></div><div class="line">        <span class="keyword">await</span> randsleep(caller=<span class="string">f"Producer <span class="subst">&#123;name&#125;</span>"</span>)</div><div class="line">        i = <span class="keyword">await</span> makeitem()</div><div class="line">        t = time.perf_counter()</div><div class="line">        <span class="keyword">await</span> q.put((i, t))</div><div class="line">        print(<span class="string">f"Producer <span class="subst">&#123;name&#125;</span> added &lt;<span class="subst">&#123;i&#125;</span>&gt; to queue."</span>)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(name: int, q: asyncio.Queue)</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">    <span class="string">"""消费者"""</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">await</span> randsleep(caller=<span class="string">f"Consumer <span class="subst">&#123;name&#125;</span>"</span>)</div><div class="line">        i, t = <span class="keyword">await</span> q.get()</div><div class="line">        now = time.perf_counter()</div><div class="line">        print(<span class="string">f"Consumer <span class="subst">&#123;name&#125;</span> got element &lt;<span class="subst">&#123;i&#125;</span>&gt;"</span></div><div class="line">              <span class="string">f" in <span class="subst">&#123;now - t:<span class="number">0.5</span>f&#125;</span> seconds."</span>)</div><div class="line">        q.task_done()</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(nprod: int, ncon: int)</span>:</span></div><div class="line">    q = asyncio.Queue()</div><div class="line">    <span class="comment"># asyncio.run()会自动运行消费者和生产者</span></div><div class="line">    producers = [asyncio.create_task(produce(n, q)) <span class="keyword">for</span> n <span class="keyword">in</span> range(nprod)]</div><div class="line">    consumers = [asyncio.create_task(consume(n, q)) <span class="keyword">for</span> n <span class="keyword">in</span> range(ncon)]</div><div class="line">    <span class="keyword">await</span> asyncio.gather(*producers) <span class="comment"># 等待生产者结束</span></div><div class="line">    <span class="keyword">await</span> q.join() <span class="comment"># 阻塞直到队列中的所有项目都被接收和处理</span></div><div class="line">    <span class="comment"># 取消消费者</span></div><div class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> consumers:</div><div class="line">        c.cancel()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    random.seed(<span class="number">444</span>)</div><div class="line">    start = time.perf_counter()</div><div class="line">    asyncio.run(main(<span class="number">2</span>, <span class="number">3</span>))</div><div class="line">    elapsed = time.perf_counter() - start</div><div class="line">    print(<span class="string">f"Program completed in <span class="subst">&#123;elapsed:<span class="number">0.5</span>f&#125;</span> seconds."</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>上面的代码逻辑流程如下：</p>
<ul>
<li>1、将向队列put任务的操作单独编写为一个生产者协程。</li>
<li>2、启动生产者和消费者</li>
<li>3、等待生产者结束，通过<code>await producer()</code>或者<code>await gather(*producers)</code>，或者其他方式。</li>
<li>4、一旦生产者结束，通过<code>await q.join()</code>等待队列中所有的项目被接受和处理完</li>
<li>5、取消消费者任务，否则消费者会一直等待不可能出现的下一个任务。</li>
</ul>
</li>
</ul>
<h3 id="3、结合线程和进程"><a href="#3、结合线程和进程" class="headerlink" title="3、结合线程和进程"></a>3、结合线程和进程</h3><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul>
<li>默认情况下，事件循环在主线程中运行，并在其线程中执行所有回调和任务，同一时刻只有一个任务在执行。需要注意的是：要处理信号和执行子进程，必须在主线程中运行事件循环。</li>
<li>如何将异步代码和多线程结合在一起使用，有下面几种方法：</li>
<li><p><code>方法一：启动一个子线程，在子线程中运行异步代码</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(i)</span>:</span></div><div class="line">    print(<span class="string">"hello"</span>, i)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(i)</div><div class="line">    <span class="keyword">return</span> i</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    tasks = [asyncio.create_task(hello(i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</div><div class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">async_main</span><span class="params">()</span>:</span></div><div class="line">    asyncio.run(main())</div><div class="line"></div><div class="line"><span class="comment"># 在子线程中运行异步任务</span></div><div class="line">t = Thread(target=async_main)</div><div class="line">t.start()</div><div class="line"></div><div class="line"><span class="comment"># 不会干扰主线程</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
</li>
<li><p><code>方法二：loop.call_soon_threadsafe()函数</code></p>
</li>
<li><p>loop.call_soon()用于注册回调，当异步任务执行完成时会在当前线程按顺序执行注册的普通函数。loop.call_soon_threadsafe()用于在一个线程中注册回调函数，在另一个线程中执行注册的普通函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(i)</span>:</span></div><div class="line">    print(<span class="string">"hello"</span>, i)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(i)</div><div class="line">    <span class="keyword">return</span> i</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    tasks = [asyncio.create_task(hello(i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</div><div class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(loop)</span>:</span></div><div class="line">    asyncio.set_event_loop(loop)</div><div class="line">    loop.run_until_complete(main())</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">more_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'More work &#123;&#125;'</span>.format(x))</div><div class="line">    time.sleep(x)</div><div class="line">    print(<span class="string">'Finished more work &#123;&#125;'</span>.format(x))</div><div class="line"></div><div class="line"><span class="comment"># 在主线程创建事件循环，并在另一个线程中启动</span></div><div class="line">new_loop = asyncio.new_event_loop()</div><div class="line">t = Thread(target=start_loop, args=(new_loop,))</div><div class="line">t.start()</div><div class="line"></div><div class="line"><span class="comment"># 在主线程中注册回调函数，在子线程中按顺序执行回调函数</span></div><div class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">1</span>)</div><div class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="comment"># 不会阻塞主线程</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
</li>
<li><p><code>方法三：asyncio.run_coroutine_threadsafe()函数</code></p>
</li>
<li><p>loop.call_soon_threadsafe()函数是同步执行回调函数，asyncio.run_coroutine_threadsafe()函数则是异步执行回调函数，传入写成函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(i)</span>:</span></div><div class="line">    print(<span class="string">"hello"</span>, i)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(i)</div><div class="line">    <span class="keyword">return</span> i</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    tasks = [asyncio.create_task(hello(i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</div><div class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(loop)</span>:</span></div><div class="line">    asyncio.set_event_loop(loop)</div><div class="line">    loop.run_until_complete(main())</div><div class="line"></div><div class="line"><span class="comment"># 在主线程创建事件循环，并在另一个线程中启动</span></div><div class="line">new_loop = asyncio.new_event_loop()</div><div class="line">t = Thread(target=start_loop, args=(new_loop,))</div><div class="line">t.start()</div><div class="line"></div><div class="line"><span class="comment"># 在主线程中注册回调协程函数，在子线程中按异步执行回调函数</span></div><div class="line">asyncio.run_coroutine_threadsafe(hello(<span class="number">3.5</span>), new_loop)</div><div class="line">asyncio.run_coroutine_threadsafe(hello(<span class="number">1.5</span>), new_loop)</div><div class="line"></div><div class="line"><span class="comment"># 不会阻塞主线程</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
</li>
<li><p><code>方法四：loop.run_in_executor(executor, func, *args)</code></p>
</li>
<li>asyncio的事件循环在背后维护着一个ThreadPoolExecutor对象，我们可以调用run_in_executor方法，把可调用对象发给它执行。</li>
<li>loop.run_in_executor()函数用于在特定的executor中执行函数。executor参数必须是 concurrent.futures.Executor实例对象，传入None表示在默认的executor中执行。返回一个可等待的协程对象。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> concurrent.futures</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocks</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="string">"""阻塞任务"""</span></div><div class="line">    time.sleep(<span class="number">0.1</span>)</div><div class="line">    <span class="keyword">return</span> n ** <span class="number">2</span></div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run_blocking_tasks</span><span class="params">(executor)</span>:</span></div><div class="line">    loop = asyncio.get_event_loop()</div><div class="line">    <span class="comment"># 在线程池中执行阻塞任务</span></div><div class="line">    blocking_tasks = [</div><div class="line">        loop.run_in_executor(executor, blocks, i)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>)</div><div class="line">    ]</div><div class="line">    completed, pending = <span class="keyword">await</span> asyncio.wait(blocking_tasks)</div><div class="line">    results = [t.result() <span class="keyword">for</span> t <span class="keyword">in</span> completed]</div><div class="line">    print(results)</div><div class="line"></div><div class="line"><span class="comment"># 创建线程池</span></div><div class="line">executor = concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>)</div><div class="line">event_loop = asyncio.get_event_loop()</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    event_loop.run_until_complete(run_blocking_tasks(executor))</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    event_loop.close()</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><ul>
<li>结合多进程运行异步代码和多线程类似，有下面几种方法：</li>
<li><p><code>方法一：启动一个子进程，在子进程中运行异步代码</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> multiprocessing</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(i)</span>:</span></div><div class="line">    print(<span class="string">"hello"</span>, i)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">strap</span><span class="params">(tx, rx)</span>:</span></div><div class="line">    loop = asyncio.new_event_loop()</div><div class="line">    asyncio.set_event_loop(loop)</div><div class="line">    loop.run_until_complete(hello(<span class="number">3</span>))</div><div class="line"></div><div class="line"><span class="comment"># 启动一个子线程，在子线程中运行异步代码</span></div><div class="line">p = multiprocessing.Process(target=strap, args=(<span class="number">1</span>, <span class="number">3</span>))</div><div class="line">p.start()</div><div class="line"></div><div class="line"><span class="comment"># 子进程和主进程不会相互干扰</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
</li>
<li><p><code>方法二：loop.run_in_executor(executor, func, *args)</code></p>
</li>
<li><p>和多线程一样，只不过是把线程池换成进程池。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> concurrent.futures</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocks</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="string">"""阻塞任务"""</span></div><div class="line">    time.sleep(<span class="number">0.1</span>)</div><div class="line">    <span class="keyword">return</span> n ** <span class="number">2</span></div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run_blocking_tasks</span><span class="params">(executor)</span>:</span></div><div class="line">    loop = asyncio.get_event_loop()</div><div class="line">    <span class="comment"># 在进程池中执行阻塞任务</span></div><div class="line">    blocking_tasks = [</div><div class="line">        loop.run_in_executor(executor, blocks, i)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>)</div><div class="line">    ]</div><div class="line">    completed, pending = <span class="keyword">await</span> asyncio.wait(blocking_tasks)</div><div class="line">    results = [t.result() <span class="keyword">for</span> t <span class="keyword">in</span> completed]</div><div class="line">    print(results)</div><div class="line"></div><div class="line"><span class="comment"># 创建进程池</span></div><div class="line">executor = concurrent.futures.ProcessPoolExecutor(max_workers=<span class="number">3</span>)</div><div class="line">event_loop = asyncio.get_event_loop()</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    event_loop.run_until_complete(run_blocking_tasks(executor))</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    event_loop.close()</div></pre></td></tr></table></figure>
</li>
<li><p><code>方法三：第三方库aiomultiprocess</code></p>
</li>
<li><p>第三方库<a href="https://github.com/jreese/aiomultiprocess" target="_blank" rel="external">aiomultiprocess</a>可以方面的将异步代码和多进程结合使用，下面是官方demo：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> request</div><div class="line"><span class="keyword">from</span> aiomultiprocess <span class="keyword">import</span> Worker</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url)</span>:</span></div><div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> request(<span class="string">"GET"</span>, url) <span class="keyword">as</span> response:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">await</span> response.text(<span class="string">"utf-8"</span>)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    p = Worker(target=get, args=(<span class="string">"https://jreese.sh"</span>, ))</div><div class="line">    response = <span class="keyword">await</span> p</div><div class="line"></div><div class="line">asyncio.run(main())</div></pre></td></tr></table></figure>
</li>
<li><p>更多的使用案例，请参考：<a href="https://pymotw.com/3/asyncio/index.html" target="_blank" rel="external">asyncio — Asynchronous I/O, event loop, and concurrency tools</a>（该系列文章本博客已翻译）</p>
</li>
</ul>
<h2 id="五、资源"><a href="#五、资源" class="headerlink" title="五、资源"></a>五、资源</h2><h3 id="可以和async-await一起使用的库"><a href="#可以和async-await一起使用的库" class="headerlink" title="可以和async/await一起使用的库"></a>可以和async/await一起使用的库</h3><ul>
<li>来自<a href="https://github.com/aio-libs" target="_blank" rel="external">aio-libs</a>：<ul>
<li><a href="https://github.com/aio-libs/aiohttp" target="_blank" rel="external">aiohttp</a>：异步HTTP客户端/服务端框架</li>
<li><a href="https://github.com/aio-libs/aioredis" target="_blank" rel="external">aioredis</a>：异步Redis客户端</li>
<li><a href="https://github.com/aio-libs/aiopg" target="_blank" rel="external">aiopg</a>：异步PostgreSQL客户端</li>
<li><a href="https://github.com/aio-libs/aiomcache" target="_blank" rel="external">aiomcache</a>：异步memcached客户端</li>
<li><a href="https://github.com/aio-libs/aiokafka" target="_blank" rel="external">aiokafka</a>：异步Kafka客户端</li>
<li><a href="https://github.com/aio-libs/aiozmq" target="_blank" rel="external">aiozmq</a>：异步ZeroMQ客户端</li>
<li><a href="https://github.com/aio-libs/aiojobs" target="_blank" rel="external">aiojobs</a>：异步后台作业调度程序</li>
<li><a href="https://github.com/aio-libs/async_lru" target="_blank" rel="external">async_lru</a>：用于异步IO的简单LRU缓存</li>
</ul>
</li>
<li>来自<a href="https://magic.io/" target="_blank" rel="external">magicstack</a>：<ul>
<li><a href="https://github.com/MagicStack/uvloop" target="_blank" rel="external">uvloop</a>：超快的事件循环，是内置asyncio事件循环的快速替代品。 底层使用Cython和ibuv实现。</li>
<li><a href="https://github.com/MagicStack/asyncpg" target="_blank" rel="external">asyncpg</a>：异步PostgreSQL客户端</li>
</ul>
</li>
<li>来自其他地方：<ul>
<li><a href="https://github.com/python-trio/trio" target="_blank" rel="external">trio</a>：类似于asyncio的异步框架，旨在更加简单易用</li>
<li><a href="https://github.com/dabeaz/curio" target="_blank" rel="external">curio</a>：类似于asyncio的异步框架，Python大牛dabeaz开发的实验性质的库</li>
<li><a href="https://github.com/Tinche/aiofiles" target="_blank" rel="external">aiofiles</a>：异步文件IO</li>
<li><a href="https://github.com/theelous3/asks" target="_blank" rel="external">asks</a>：异步HTTP客户端，跟requests类似</li>
<li><a href="https://github.com/jonathanslenders/asyncio-redis" target="_blank" rel="external">asyncio-redis</a>：异步Redis客户端</li>
<li><a href="https://github.com/dano/aioprocessing" target="_blank" rel="external">aioprocessing</a>：将多进程和asyncio结合在一起</li>
<li><a href="https://github.com/Scille/umongo" target="_blank" rel="external">umongo</a>：异步MongoDB客户端</li>
<li><a href="https://github.com/alex-sherman/unsync" target="_blank" rel="external">unsync</a>：通过在单独的线程中使用环境事件循环来取消同步asyncio</li>
<li><a href="https://github.com/vxgmichel/aiostream" target="_blank" rel="external">aiostream</a>：异步版的itertools</li>
</ul>
</li>
<li><a href="https://github.com/timofurrer/awesome-asyncio" target="_blank" rel="external">awesome-asyncio</a></li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://segmentfault.com/a/1190000001813992" target="_blank" rel="external">Python 中的进程、线程、协程、同步、异步、回调</a></li>
<li><a href="http://python.jobbole.com/88291/" target="_blank" rel="external">深入理解 Python 异步编程(上)</a></li>
<li><a href="https://www.jianshu.com/p/55eb83d60ab1" target="_blank" rel="external">简明网络I/O模型—同步异步阻塞非阻塞之惑</a></li>
<li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a></li>
<li><a href="https://www.jianshu.com/p/5ebd9c5727f0" target="_blank" rel="external">I/O 的五大模型：阻塞、非阻塞、复用、信号驱动、异步</a></li>
<li><a href="https://www.cnblogs.com/Anker/p/3254269.html" target="_blank" rel="external">网络IO之阻塞、非阻塞、同步、异步总结</a></li>
<li><a href="https://juejin.im/post/5b0014b7518825426e023666" target="_blank" rel="external">进程、线程和协程的概念</a></li>
<li><a href="https://www.cnblogs.com/lxmhhy/p/6041001.html" target="_blank" rel="external">进程和线程、协程的区别</a></li>
<li><a href="https://www.jianshu.com/p/f11724034d50" target="_blank" rel="external">进程，线程，协程与并行，并发</a></li>
<li><a href="https://www.jianshu.com/p/8cd05a23822e" target="_blank" rel="external">[译] Python 3.5 协程究竟是个啥</a></li>
<li><a href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/" target="_blank" rel="external">HOW THE HECK DOES ASYNC/AWAIT WORK IN PYTHON 3.5?</a></li>
<li>《流畅的Python》</li>
<li><a href="https://www.python.org/dev/peps/pep-0255/" target="_blank" rel="external">[PEP 0255]Simple Generators</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0342/" target="_blank" rel="external">[PEP 0342]Coroutines via Enhanced Generators</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0380/" target="_blank" rel="external">[PEP 0380]Syntax for Delegating to a Subgenerator</a></li>
<li><a href="https://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3" target="_blank" rel="external">In practice, what are the main uses for the new “yield from” syntax in Python 3.3?</a></li>
<li><a href="https://juejin.im/post/5b3af9fb51882507d4487144" target="_blank" rel="external">深入理解Python的yield from语法</a></li>
<li><a href="https://www.jianshu.com/p/87da832730f5" target="_blank" rel="external">Python yield from 用法详解</a></li>
<li><a href="https://vvl.me/2015/10/31/2015-10-31-coroutines-with-async-and-await-syntax-chinese/" target="_blank" rel="external">PEP 0492 Coroutines with async and await syntax 中文翻译</a></li>
<li><a href="https://linux.cn/article-8051-1.html" target="_blank" rel="external">雾里看花之 Python Asyncio</a></li>
<li><a href="http://python.jobbole.com/87988/" target="_blank" rel="external">Python 中的异步编程：Asyncio</a></li>
<li><a href="https://dev.to/welldone2094/async-programming-in-python-with-asyncio-12dl" target="_blank" rel="external">Async programming in Python with asyncio</a></li>
<li><a href="https://stackoverflow.com/questions/49005651/how-does-asyncio-actually-work/51116910" target="_blank" rel="external">How does asyncio actually work?</a></li>
<li><a href="http://python.jobbole.com/85117/" target="_blank" rel="external">Python “黑魔法” 之 Generator Coroutines</a></li>
<li><a href="http://python.jobbole.com/87310/" target="_blank" rel="external">Python黑魔法 — 异步IO（ asyncio） 协程</a></li>
<li><a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="external">asyncio — Asynchronous I/O</a></li>
<li><a href="http://www.qingpingshan.com/jb/python/322500.html" target="_blank" rel="external">Python asyncio详解</a></li>
<li><a href="http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html" target="_blank" rel="external">A Web Crawler With asyncio Coroutines</a></li>
<li><a href="https://juejin.im/post/5b3c4b9e6fb9a04f8d6b94de" target="_blank" rel="external">手把手教你如何使用Python的异步IO框架：asyncio（上）</a></li>
<li><a href="https://juejin.im/post/5b3f540af265da0f742ec5e1" target="_blank" rel="external">手把手教你如何使用Python的异步IO框架：asyncio（中）</a></li>
<li><a href="https://juejin.im/post/5b42e404e51d4519873f1a1b" target="_blank" rel="external">手把手教你如何使用Python的异步IO框架：asyncio（下）</a></li>
<li><a href="https://vvl.me/2016/03/12/python-coroutines/" target="_blank" rel="external">Python之asyncio</a></li>
<li><a href="https://stackoverflow.com/questions/52582685/using-asyncio-queue-for-producer-consumer-flow/52615705#52615705" target="_blank" rel="external">Using asyncio.Queue for producer-consumer flow</a></li>
<li><a href="https://www.youtube.com/watch?v=0kXaLh8Fz3k&amp;feature=youtu.be&amp;t=10m30s" target="_blank" rel="external">John Reese - Thinking Outside the GIL with AsyncIO and Multiprocessing - PyCon 2018</a></li>
<li><a href="https://hackernoon.com/threaded-asynchronous-magic-and-how-to-wield-it-bba9ed602c32" target="_blank" rel="external">Threaded Asynchronous Magic and How to Wield It</a></li>
<li><a href="https://juejin.im/entry/5aabb949f265da23a04951df" target="_blank" rel="external">asyncio中使用阻塞函数</a></li>
<li><a href="https://github.com/jreese/aiomultiprocess" target="_blank" rel="external">aiomultiprocess</a></li>
<li><a href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/" target="_blank" rel="external">Some thoughts on asynchronous API design in a post-async/await world</a></li>
</ul>
</the></excerpt>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/02/16/Python异步编程详解/">Python异步编程详解</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">HatBoy</a></p>
        <p><span>发布时间:</span>2019-02-16, 15:37:14</p>
        <p><span>最后更新:</span>2019-02-16, 15:48:50</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/02/16/Python异步编程详解/" title="Python异步编程详解">https://hatboy.github.io/2019/02/16/Python异步编程详解/</a>
            <span class="copy-path" data-clipboard-text="原文: https://hatboy.github.io/2019/02/16/Python异步编程详解/　　作者: HatBoy" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/01/22/Golang中的指针、结构体、方法、方法集和接口/">
                    Golang中的指针、结构体、方法、方法集和接口
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、异步编程相关概念"><span class="toc-number">1.</span> <span class="toc-text">一、异步编程相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、I-O模型"><span class="toc-number">1.1.</span> <span class="toc-text">1、I/O模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、同步和异步、阻塞和非阻塞"><span class="toc-number">1.2.</span> <span class="toc-text">2、同步和异步、阻塞和非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、并发和并行"><span class="toc-number">1.3.</span> <span class="toc-text">3、并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、进程、线程和协程"><span class="toc-number">1.4.</span> <span class="toc-text">4、进程、线程和协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、异步编程"><span class="toc-number">1.5.</span> <span class="toc-text">5、异步编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Python异步编程进化史"><span class="toc-number">2.</span> <span class="toc-text">二、Python异步编程进化史</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、生成器yield"><span class="toc-number">2.1.</span> <span class="toc-text">1、生成器yield</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、yield-from"><span class="toc-number">2.2.</span> <span class="toc-text">2、yield from</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1、替代for循环"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1、替代for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2、打开双通道"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2、打开双通道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、asyncio框架"><span class="toc-number">2.3.</span> <span class="toc-text">3、asyncio框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、async-await-原生协程"><span class="toc-number">2.4.</span> <span class="toc-text">4、async/await 原生协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、将-async-await-看做异步编程的-API"><span class="toc-number">2.5.</span> <span class="toc-text">5、将 async/await 看做异步编程的 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、总结Python异步编程版本细节"><span class="toc-number">2.6.</span> <span class="toc-text">6、总结Python异步编程版本细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、asyncio工作原理"><span class="toc-number">3.</span> <span class="toc-text">三、asyncio工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#协程对象"><span class="toc-number">3.1.</span> <span class="toc-text">协程对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件循环"><span class="toc-number">3.2.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-amp-Task对象"><span class="toc-number">3.3.</span> <span class="toc-text">Future & Task对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Future对象"><span class="toc-number">3.3.1.</span> <span class="toc-text">Future对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task对象"><span class="toc-number">3.3.2.</span> <span class="toc-text">Task对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例分析"><span class="toc-number">3.4.</span> <span class="toc-text">实例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、asyncio使用详解"><span class="toc-number">4.</span> <span class="toc-text">四、asyncio使用详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、基本使用"><span class="toc-number">4.1.</span> <span class="toc-text">1、基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#并发运行任务"><span class="toc-number">4.1.1.</span> <span class="toc-text">并发运行任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#等待任务"><span class="toc-number">4.1.2.</span> <span class="toc-text">等待任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#回调"><span class="toc-number">4.1.3.</span> <span class="toc-text">回调</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、队列"><span class="toc-number">4.2.</span> <span class="toc-text">2、队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、结合线程和进程"><span class="toc-number">4.3.</span> <span class="toc-text">3、结合线程和进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程"><span class="toc-number">4.3.1.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多进程"><span class="toc-number">4.3.2.</span> <span class="toc-text">多进程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、资源"><span class="toc-number">5.</span> <span class="toc-text">五、资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可以和async-await一起使用的库"><span class="toc-number">5.1.</span> <span class="toc-text">可以和async/await一起使用的库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-number">5.2.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Python异步编程详解　| HatBoy的个人主页　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function(){
            this.page.url = 'https://hatboy.github.io/2019/02/16/Python异步编程详解/';
            this.page.identifier = '2019/02/16/Python异步编程详解/';
        };
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = '//hatboy007.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

</section>


    




    <div class="scroll" id="post-nav-button">
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/01/22/Golang中的指针、结构体、方法、方法集和接口/" title="下一篇: Golang中的指针、结构体、方法、方法集和接口">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/02/16/Python异步编程详解/">Python异步编程详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/22/Golang中的指针、结构体、方法、方法集和接口/">Golang中的指针、结构体、方法、方法集和接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/11/Python-KCP协议实例/">Python KCP协议实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/14/Teensy之生成Payload/">Teensy之生成Payload</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/14/Teensy之简单代码编写/">Teensy之简单代码编写</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/14/Teensy之开发环境部署及基本用法/">Teensy之开发环境部署及基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/MySQL报错注入/">MySQL报错注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/内网端口转发及穿透/">内网端口转发及穿透</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/28/Python编写socks5服务器/">Python编写socks5服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/19/Python沙箱逃逸总结/">Python沙箱逃逸总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/如何恢复丢失的Python源代码如果它还在内存中运行/">如何恢复丢失的Python源代码如果它还在内存中运行</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/08/pathlib：文件系统路径作为对象/">pathlib：文件系统路径作为对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio：异步IO、事件循环和并发/">asyncio：异步IO、事件循环和并发</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之调试asyncio/">asyncio之调试asyncio</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之协程结合线程和进程/">asyncio之协程结合线程和进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之接收Unix信号/">asyncio之接收Unix信号</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之使用子进程/">asyncio之使用子进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之与DNS服务进行交互/">asyncio之与DNS服务进行交互</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之使用SSL/">asyncio之使用SSL</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之使用协程和流的异步I-O/">asyncio之使用协程和流的异步I/O</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之协议抽象类的异步I-O/">asyncio之协议抽象类的异步I/O</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之同步原语/">asyncio之同步原语</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之用控制结构组建协程/">asyncio之用控制结构组建协程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之并发执行Tasks/">asyncio之并发执行Tasks</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之异步生产结果/">asyncio之异步生产结果</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之定时调度常规函数/">asyncio之定时调度常规函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之使用协程处理多任务/">asyncio之使用协程处理多任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/asyncio之异步并发的概念/">asyncio之异步并发的概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/Python上下文管理器/">Python上下文管理器</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/Python-importlib讲解/">Python importlib讲解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/第七章-用Cython包装C库/">第七章 用Cython包装C库</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/16/第六章-组织Cython代码/">第六章 组织Cython代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/10/第五章-Cython和扩展类型/">第五章 Cython和扩展类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/第四章-Cython实践：N-body模拟/">第四章 Cython实践：N-body模拟</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/Python性能分析与调试/">Python性能分析与调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/17/第三章-深入Cython/">第三章 深入Cython</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/03/第二章-编译和运行Cython代码/">第二章 编译和运行Cython代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/02/第一章-Cython简介/">第一章 Cython简介</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2019 HatBoy
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        $("a").attr("target", "_blank");
        $("#scroll a, #toc a").removeAttr("target");
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>